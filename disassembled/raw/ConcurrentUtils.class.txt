Compiled from "ConcurrentUtils.java"
public class org.apache.commons.lang3.concurrent.ConcurrentUtils {
  static java.lang.Throwable checkedException(java.lang.Throwable);
  public static <T> java.util.concurrent.Future<T> constantFuture(T);
  public static <K, V> V createIfAbsent(java.util.concurrent.ConcurrentMap<K, V>, K, org.apache.commons.lang3.concurrent.ConcurrentInitializer<V>) throws org.apache.commons.lang3.concurrent.ConcurrentException;
  public static <K, V> V createIfAbsentUnchecked(java.util.concurrent.ConcurrentMap<K, V>, K, org.apache.commons.lang3.concurrent.ConcurrentInitializer<V>);
  public static org.apache.commons.lang3.concurrent.ConcurrentException extractCause(java.util.concurrent.ExecutionException);
  public static org.apache.commons.lang3.concurrent.ConcurrentRuntimeException extractCauseUnchecked(java.util.concurrent.ExecutionException);
  public static void handleCause(java.util.concurrent.ExecutionException) throws org.apache.commons.lang3.concurrent.ConcurrentException;
  public static void handleCauseUnchecked(java.util.concurrent.ExecutionException);
  public static <T> T initialize(org.apache.commons.lang3.concurrent.ConcurrentInitializer<T>) throws org.apache.commons.lang3.concurrent.ConcurrentException;
  public static <T> T initializeUnchecked(org.apache.commons.lang3.concurrent.ConcurrentInitializer<T>);
  public static <K, V> V putIfAbsent(java.util.concurrent.ConcurrentMap<K, V>, K, V);
  private org.apache.commons.lang3.concurrent.ConcurrentUtils();
}
